function processAndRenderReport(consIndex, shouldPopulateFilters = false) {
            // Check karein ki data Shipper se lena hai ya SMTP se
            const dataSource = (consIndex === 24) ? rawSheets.smtp : rawSheets.shipper;
            
            const headers = dataSource[0];
            if (!headers) return;

            const sizeIndex = headers.findIndex(h => String(h).toUpperCase().includes('SIZE'));
            const relevantRows = dataSource.slice(1).filter(row => String(row[consIndex] || '').trim() === selectedShipper);
            
            const blGroups = {};
            const excludedTerms = ['CT3', 'CT4', 'MICT', 'SPRH', 'T2'];
            
            relevantRows.forEach(row => {
                // Column mapping based on data source
                const contNo = (consIndex === 24) ? String(row[2] || '').trim() : String(row[0] || '').trim();
                const blNo = (consIndex === 24) ? String(row[9] || 'N/A').trim() : String(row[2] || 'N/A').trim();
                const sizeValue = String(row[sizeIndex] || '').includes('40') ? 40 : 20;
                if (!blGroups[blNo]) {
                    blGroups[blNo] = { 
                        blNo, stats: { total: 0, s20: 0, s40: 0, railed: 0, pending: 0, r20: 0, r40: 0, p20: 0, p40: 0 },
                        line: '-', vessel: '-', handoverDt: '-', 
                        railedDetails: [], pendingRemarks: [], smtpBRemarks: [], isAnySmtp: false
                    };
                }

                const smtpRow = rawSheets.smtp.find(s => String(s[2] || '').trim() === contNo);
                const webRow = rawSheets.website.find(w => String(w[3] || '').trim() === contNo);
                
                if (smtpRow) {
                    blGroups[blNo].isAnySmtp = true;
                    if (blGroups[blNo].vessel === '-') blGroups[blNo].vessel = smtpRow[5] || '-'; 
                    if (blGroups[blNo].handoverDt === '-') blGroups[blNo].handoverDt = smtpRow[18] || smtpRow[17] || '-'; 
                    if (blGroups[blNo].line === '-') blGroups[blNo].line = smtpRow[23] || '-'; 
                    const cellBVal = String(smtpRow[1] || '').trim();
                    if (cellBVal && !excludedTerms.includes(cellBVal.toUpperCase())) {
                        if (!blGroups[blNo].smtpBRemarks.includes(cellBVal)) blGroups[blNo].smtpBRemarks.push(cellBVal);
                    }
                }

                const railDateRaw = webRow ? webRow[8] : '';
                const railDateStr = String(railDateRaw || '').trim();
                const isRailed = railDateStr && !['-', 'NOT RAILOUT', 'PENDING', '', 'N/A'].includes(railDateStr.toUpperCase());

                if (isRailed) {
                    const trainNo = String(webRow[4] || '').trim();
                    const remark = trainDateRemarksMap[`${trainNo}_${railDateStr}`] || String(webRow[9] || '-').trim();
                    const formattedRailDate = formatToDDMMYYYY_HHMM(railDateRaw);
                    let existingDetail = blGroups[blNo].railedDetails.find(d => d.train === trainNo && d.date === formattedRailDate);
                    if (existingDetail) existingDetail.count++;
                    else blGroups[blNo].railedDetails.push({ train: trainNo || 'Railed', date: formattedRailDate, remark: remark, count: 1 });
                    if (sizeValue === 20) blGroups[blNo].stats.r20++; else blGroups[blNo].stats.r40++;
                } else {
                    const pRem = (webRow && webRow[9] && webRow[9] !== '-') ? webRow[9] : (smtpRow && smtpRow[22] ? smtpRow[22] : null);
                    if (pRem && !blGroups[blNo].pendingRemarks.includes(pRem)) blGroups[blNo].pendingRemarks.push(pRem);
                    if (sizeValue === 20) blGroups[blNo].stats.p20++; else blGroups[blNo].stats.p40++;
                }
                blGroups[blNo].stats.total++;
                if (sizeValue === 20) blGroups[blNo].stats.s20++; else blGroups[blNo].stats.s40++;
                if (isRailed) blGroups[blNo].stats.railed++; else blGroups[blNo].stats.pending++;
            });

            // --- UPDATED SORTING LOGIC ---
            currentShipperAllGroups = Object.values(blGroups);

            currentShipperAllGroups.sort((a, b) => {
                const isNotHandoverA = (!a.isAnySmtp && a.stats.railed === 0);
                const isNotHandoverB = (!b.isAnySmtp && b.stats.railed === 0);

                if (isNotHandoverA && !isNotHandoverB) return -1;
                if (!isNotHandoverA && isNotHandoverB) return 1;

                const parseSortDate = (str) => {
                    if (!str || str === '-' || str === 'N/A') return 0;
                    const parts = str.split(/[-.\/\s]/);
                    if (parts.length < 3) return 0;
                    
                    let d = parseInt(parts[0]);
                    let m = parseInt(parts[1]) - 1;
                    let y = parseInt(parts[2]);
                    if (y < 100) y += 2000;
                    
                    return new Date(y, m, d).getTime();
                };

                const dateA = parseSortDate(a.handoverDt);
                const dateB = parseSortDate(b.handoverDt);

                return dateB - dateA; // New to Old
            });

            // VESSEL FILTER LOGIC FIX (Auto-Select & Auto-Render)
            if (shouldPopulateFilters) {
                // 1. Reset
                window.selectedVessels = [];
                document.getElementById('vesselDropdownLabel').innerText = "Select Vessels";

                // 2. Prepare Map
                const vesselDateMap = {};
                currentShipperAllGroups.forEach(g => {
                    let currentVal = g.vessel && g.vessel !== '-' && g.vessel !== '' ? g.vessel : 'NOT HANDOVER';
                    const currentDt = g.handoverDt;

                    const parseDate = (str) => {
                        if (!str || str === '-' || str === 'N/A') return 0;
                        const p = str.split(/[-.\/\s]/);
                        let y = parseInt(p[2]); if (y < 100) y += 2000;
                        return new Date(y, parseInt(p[1]) - 1, parseInt(p[0])).getTime();
                    };
                    const newTime = parseDate(currentDt);

                    if (!vesselDateMap[currentVal] || newTime > vesselDateMap[currentVal].time) {
                        vesselDateMap[currentVal] = { name: currentVal, time: newTime };
                    }
                });

                // 3. Sort & Force NOT HANDOVER to top
                let sortedObjects = Object.values(vesselDateMap).sort((a, b) => b.time - a.time);
                let sortedVesselNames = sortedObjects.map(v => v.name);

                if (sortedVesselNames.includes('NOT HANDOVER')) {
                    sortedVesselNames = sortedVesselNames.filter(v => v !== 'NOT HANDOVER');
                    sortedVesselNames.unshift('NOT HANDOVER');
                }

                // 4. AUTO-SELECT LOGIC: Only Select Vessels with Pending Units
                const pendingVessels = [];
                sortedVesselNames.forEach(v => {
                    const relatedGroups = currentShipperAllGroups.filter(g => {
                        const gVessel = (g.vessel && g.vessel !== '-' && g.vessel !== '') ? g.vessel : 'NOT HANDOVER';
                        return gVessel === v;
                    });

                    let total = 0;
                    let arrived = 0;
                    relatedGroups.forEach(g => {
                        total += g.stats.total;
                        arrived += g.railedDetails.reduce((acc, d) => /TRAIN ARRIVED/i.test(d.remark) ? acc + d.count : acc, 0);
                    });

                    // If pending units exist (Total > Arrived), add to default selection
                    if (total > arrived) {
                        pendingVessels.push(v);
                    }
                });

                // Set selection logic
                if (pendingVessels.length > 0) {
                    window.selectedVessels = pendingVessels;
                    document.getElementById('vesselDropdownLabel').innerText = `${pendingVessels.length} Active Vessels Selected`;
                } else {
                    document.getElementById('vesselDropdownLabel').innerText = "All Completed (Select to View)";
                }

                // 5. Populate Menu
                window.populateVesselFilters(sortedVesselNames);

                // 6. BL Filter
                const uniqueBLs = currentShipperAllGroups.map(g => g.blNo).filter(Boolean).sort();
                blFilter.innerHTML = '<option value="ALL">All BLs</option>' + uniqueBLs.map(b => `<option value="${b}">${b}</option>`).join('');

                // 7. *** CRITICAL FIX: APPLY FILTERS IMMEDIATELY ***
                applyFilters();
            }
        }
